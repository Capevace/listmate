import type {
	DataObject,
	DataObjectRemote,
	FileReference,
} from '@prisma/client';
import type { Except } from 'type-fest';
import type { Resource, SourceType } from '~/models/resource/resource.types';

import invariant from 'tiny-invariant';
import { prisma as db } from '~/db.server';
import { dataObjectToResource } from '~/models/resource/adapters/adapters.server';

//
// READ
//

/**
 * Find a resource by a given Resource / DataObject ID.
 *
 * @param resourceId The resource ID to find
 * @returns Promise<Resource>
 */
export async function findResourceById(
	id: Resource['id']
): Promise<Resource | null> {
	const dataObject = await db.dataObject.findUnique({
		where: {
			id,
		},
		include: {
			remotes: true,
			values: true,
			thumbnail: true,
		},
	});

	return dataObject ? await dataObjectToResource(dataObject) : null;
}

/**
 * Find a Resource by an associated remote URI.
 *
 * For example you could pass SourceType.SPOTIFY
 * and "spotify:track:4iV5W9uYEdYUVa79Axb7Rh" to
 * find the associated track in the Spotify API.
 * @param api The type of the remote URI
 * @param uri The remote URI to find
 * @returns
 */
export async function findResourceByRemoteUri(
	api: SourceType,
	uri: DataObjectRemote['uri']
): Promise<Resource | null> {
	const remote = await db.dataObjectRemote.findUnique({
		where: {
			api_uri: {
				api,
				uri,
			},
		},
	});

	if (!remote) return null;

	return findResourceById(remote.dataObjectId);
}

//##
// Create Resources \\
//####

/**
 * Create a new Resource / DataObject.
 *
 * The ID property can be omitted from the resource,
 * and will be generated by the database.
 *
 * @param resource The resource to create
 * @returns Promise<Resource>
 */
export async function createResource(
	resource: Except<Resource, 'id'>
): Promise<Resource> {
	const dataObject = await db.dataObject.create({
		data: {
			title: resource.title,
			type: resource.type,
			thumbnailFileId: resource.thumbnail?.id || null,
		},
	});

	await upsertValues({ ...resource, id: dataObject.id });

	const fullObject = await db.dataObject.findUnique({
		where: {
			id: dataObject.id,
		},
		include: {
			remotes: true,
			values: true,
			thumbnail: true,
		},
	});

	invariant(fullObject, 'Could not create resource');

	return dataObjectToResource(fullObject);
}

//##
// Update Resources \\
//####

/**
 * Create or update a new resource.
 *
 * The resource ID is required, as it is used to identify the resource.
 * @todo Add a method to upsert a resource by its URIs
 *
 * @param resource
 * @returns Promise<Resource>
 */
export async function upsertResource(resource: Resource): Promise<Resource> {
	const dataObject = await db.dataObject.upsert({
		where: {
			id: resource.id,
		},
		// TODO: when used with the if clause below, we can try and find similar dataobjects
		update: {
			title: resource.title,
			type: resource.type,
			thumbnailFileId: resource.thumbnail?.id || null,
		},
		create: {
			id: resource.id,
			title: resource.title,
			type: resource.type,
			thumbnailFileId: resource.thumbnail?.id || null,
		},
		include: {
			remotes: true,
		},
	});

	await upsertValues(resource);

	const fullObject = await db.dataObject.findUnique({
		where: {
			id: dataObject.id,
		},
		include: {
			remotes: true,
			values: true,
			thumbnail: true,
		},
	});

	invariant(fullObject, 'Could not upsert data object');

	return dataObjectToResource(fullObject);
}

/**
 * Set a resource's values. DataObjectValues will be created or updated accordingly.
 *
 * ValueRef relationships will be properly added to the database.
 *
 * @param resource
 */
async function upsertValues(resource: Resource) {
	for (const [key, valueRef] of Object.entries(resource.values)) {
		if (!valueRef) continue;

		await db.dataObjectValue.upsert({
			where: {
				dataObjectId_key: {
					dataObjectId: resource.id,
					key,
				},
			},
			update: {
				value: valueRef.value,
				valueDataObjectId: valueRef.ref,
			},
			create: {
				dataObjectId: resource.id,
				key,
				value: valueRef.value,
				valueDataObjectId: valueRef.ref,
			},
		});
	}
}

/**
 * Create or update multiple resources.
 *
 * This should only be used for seeding the DB, as IDs are required.
 * The function call will overwrite existing resources with given IDs.
 *
 * Instead of an array, a map will be returned, with the resource ID as key.
 *
 * @param resourcesToCreate A list of the resources to create or update.
 * @returns Promise<Record<string, Resource>> A map of the created/updated resources.
 */
export async function upsertResources(
	resourcesToCreate: Resource[]
): Promise<Record<string, Resource>> {
	let resources: Record<string, Resource> = {};

	for (const resource of resourcesToCreate) {
		const createdObject = await upsertResource(resource);
		resources[createdObject.id] = createdObject;
	}

	return resources;
}

/**
 * Attach a remote URI to a resource.
 *
 * For example, you can attach a Spotify URI like "spotify:track:4iV5W9uYEdYUVa79Axb7Rh"
 * to a DataObject, and it will be identifiable by the Spotify Import API.
 *
 * @param resourceId The Resource ID to attach the remote URI to
 * @param api The type of the remote URI
 * @param uri The remote URI
 * @returns Promise<DataObjectRemote>
 */
export async function attachRemoteUri(
	resourceId: Resource['id'],
	api: SourceType,
	uri: DataObjectRemote['uri']
): Promise<DataObjectRemote> {
	return db.dataObjectRemote.create({
		data: {
			dataObjectId: resourceId,
			api,
			uri,
		},
	});
}

/**
 * Attach a FileReference to a resource as a thumbnail
 *
 * @param resourceId The ID of the Resource to add
 * @param fileRef The FileReference of the thumbnail image
 * @returns Promise<DataObject>
 */
export function attachThumbnailToResource(
	resourceId: string,
	fileRef: FileReference
): Promise<DataObject> {
	return db.dataObject.update({
		where: {
			id: resourceId,
		},
		data: {
			thumbnailFileId: fileRef.id,
		},
	});
}

//##
// Delete Resources \\
//####
